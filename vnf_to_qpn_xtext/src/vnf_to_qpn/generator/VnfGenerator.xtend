/*
 * generated by Xtext 2.15.0
 */
package vnf_to_qpn.generator

import QPN.impl.ArcImpl
import QPN.impl.GroupImpl
import QPN.impl.ImmediateTransitionImpl
import QPN.impl.PetriNetImpl
import QPN.impl.PlaceImpl
import QPN.impl.SubGroupImpl
import QPN.impl.SubSubGroupImpl
import QPN.impl.TimedTransitionImpl
import java.io.IOException
import java.io.StringWriter
import org.apache.log4j.Logger
import org.eclipse.core.runtime.Platform
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.URIConverter
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class VnfGenerator extends AbstractGenerator {
	
	Logger logger = Logger.getLogger(VnfGenerator)
	
		var PetriNetImpl petrinet=null
		var immediateTransitionListTemp = newArrayList
		var immediateTransitionList = newArrayList
		var timedTransitionList = newArrayList
		var placeList = newArrayList
		var ArcListTemp = newArrayList
		var ArcList = newArrayList
		var flyingPlacesList = newArrayList
		val int componentOffsetHorizontal=100
		val int componentOffsetVertical =50
		var int currentOffsetHorizontal=componentOffsetHorizontal
		var int timedTransitionVertical=50
		var int placeVertical=150
		var int immediateTransitionVertical=250
		var String weightDefault="none"//not defined
		
		var int id = 0
		
		

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val bundle = Platform.getBundle("Transform_Xtext_VNF")
		val mapperClass = bundle.loadClass(
			"org.emoflon.ibex.tgg.run.transform_xtext_vnf.xtext.integration.TransformTransformation")
		val mapper = mapperClass.getDeclaredConstructor().newInstance() as ICSToASTransformation
		try {
			val results = mapper.generateASFromCS(resource)
			if(results.size > 0)
				logger.warn(results.join(", "))

			var stringWriter = new StringWriter()	
			mapper.getAS().save(new URIConverter.WriteableOutputStream(stringWriter, "UTF-8"), null);
			fsa.generateFile('abstractSyntax.xmi', stringWriter.getBuffer().toString())
			stringWriter.close		

			stringWriter = new StringWriter()	
			mapper.getCS().save(new URIConverter.WriteableOutputStream(stringWriter, "UTF-8"), null);
			fsa.generateFile('concreteSyntax.xmi', stringWriter.getBuffer().toString())
			stringWriter.close
			
		} catch (IOException e) {
			e.printStackTrace
		}
		
		// generate qpn model
		
		val bundle2 = Platform.getBundle("Transform_VNF_QPN")
		val mapperClass2 = bundle2.loadClass(
			"org.emoflon.ibex.tgg.run.transform_vnf_qpn.integration.TransformTransformation")
		val mapper2 = mapperClass2.getDeclaredConstructor().newInstance() as IASToQPNTransformation
		try {
			mapper2.generateQPNFromAS(mapper.getAS())

			val stringWriter2 = new StringWriter()	
			mapper2.getQPN().save(new URIConverter.WriteableOutputStream(stringWriter2, "UTF-8"), null);
			fsa.generateFile('QPNSyntax.xmi', stringWriter2.getBuffer().toString())
			stringWriter2.close
			
		} catch (IOException e) {
			e.printStackTrace
		}
		generate(mapper2.getQPN(),fsa)
	}
	
	def generate(Resource resource, IFileSystemAccess2 fsa)
	{				
		for (content: resource.contents)
		{
			if(content instanceof PetriNetImpl)
			{
				petrinet = content as PetriNetImpl
			} 
			else if(content instanceof ImmediateTransitionImpl)
			{
				immediateTransitionListTemp.add(content as ImmediateTransitionImpl)
			}
		
		}
		//if(!immediateTransition.isEmpty()
		//bei jedem place testen, ob es eine Arc gibt, welcher nicht in einer Group ist und zu einer der immediateTransitionTemp gehört.
		//falls ja: füge als nächstes diese immediateTransition hinzu und lösche sie aus immediateTransitionTemp
		//prüfe erneut, ob eis einen Arc gibt, welcher zu einer (anderen) immediateTransition führt
		
		
		//all arcs which are not in any group
		
		for (arc : petrinet.arcs)
		{
			ArcListTemp.add(arc as ArcImpl)
		}
		
		for (place :petrinet.flyingPlaces)
		{
			flyingPlacesList.add(place as PlaceImpl)
		}
		
		for (group : petrinet.groups)
		{
			var GroupImpl tempGroup = group as GroupImpl
			
			var SubGroupImpl fwd = tempGroup.forward as SubGroupImpl
			var SubGroupImpl bwd = tempGroup.backward as SubGroupImpl
			
			for(in :fwd.in)
			{
				dismantleSubSubGroup((in as SubSubGroupImpl), (tempGroup.name+"_up"))
			}
			
			for(out :fwd.out)
			{
				dismantleSubSubGroup((out as SubSubGroupImpl), (tempGroup.name+"_up"))
			}
			
			for(func :fwd.function)
			{
				dismantleSubSubGroup((func as SubSubGroupImpl), (tempGroup.name+"_up"))
			}
			
			for(in :bwd.in)
			{
				dismantleSubSubGroup((in as SubSubGroupImpl), (tempGroup.name+"_down"))
			}
			
			for(out :bwd.out)
			{
				dismantleSubSubGroup((out as SubSubGroupImpl), (tempGroup.name+"_down"))
			}
			
			for(func :bwd.function)
			{
				dismantleSubSubGroup((func as SubSubGroupImpl), (tempGroup.name+"_down"))
			}
			
			currentOffsetHorizontal = currentOffsetHorizontal + componentOffsetHorizontal
			currentOffsetHorizontal = currentOffsetHorizontal + componentOffsetHorizontal
		}
		
		//copy all arcs to ArcList
		for(arc : ArcListTemp)
		{
			var ArcImpl tempArc = arc as ArcImpl
			tempArc.ID = "0." + id.toString
			id ++
			ArcList.add(tempArc)
		}
		
		for(place : flyingPlacesList)
		{
			var PlaceImpl tempPlace = place as PlaceImpl 
			tempPlace.location = "y=\""+placeVertical+"\" x=\""+currentOffsetHorizontal+"\""
			currentOffsetHorizontal = currentOffsetHorizontal + componentOffsetHorizontal
			
			tempPlace.ID = "0." + id.toString
			id ++
			placeList.add(tempPlace)			
		}
		
		
		var String output = "" 
		
		for(place : placeList)
		{
			output = output +generatePlace(place as PlaceImpl)
		}
		
		for(tTransition : timedTransitionList)
		{
			output = output+generateTimedTransition(tTransition as TimedTransitionImpl)
		}
		
		for(iTransition : immediateTransitionList)
		{
			output = output +generateImmediateTransition(iTransition as ImmediateTransitionImpl)
		}
		
		for(arc : ArcList)
		{
			output = output+generateArc(arc as ArcImpl)
		}
		
		 var String pre='''<?xml version="1.0" encoding="UTF-8"?>
							<net gridActive="true" id="0" netclass="SCPN" sharpEdges="false"
		  						xmlns="http://pdv.cs.tu-berlin.de/TimeNET/schema/SCPN"
		  						xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pdv.cs.tu-berlin.de/TimeNET/schema/SCPN etc/schemas/SCPN.xsd">'''
		//TODO wrap PetriNet on content
		
		fsa.generateFile('qpn.xml', pre +output+'''</net>''')
		
		
		// clean up, prepare for next generation of models
		ArcList.clear()
		ArcListTemp.clear()
		immediateTransitionList.clear()
		immediateTransitionListTemp.clear()
		timedTransitionList.clear()
		placeList.clear()
		flyingPlacesList.clear()
		
		id = 0
		currentOffsetHorizontal = componentOffsetHorizontal
	}
	
	def dismantleSubSubGroup(SubSubGroupImpl subSubGroup, String groupName)
	{
		for ( transition: subSubGroup.transitions)
			{
				if (transition instanceof TimedTransitionImpl)
				{
					var TimedTransitionImpl tTransition= transition as TimedTransitionImpl
					//TODO position
					tTransition.location = "y=\""+timedTransitionVertical+"\" x=\""+currentOffsetHorizontal+"\""
					currentOffsetHorizontal = currentOffsetHorizontal + componentOffsetHorizontal
					tTransition.ID = "0." + id.toString
					id ++
					tTransition.name = groupName;
					
					
					timedTransitionList.add(tTransition)
				
				}
				else if (transition instanceof ImmediateTransitionImpl)
				{
					var ImmediateTransitionImpl iTransition =transition as ImmediateTransitionImpl
					
					iTransition.location ="y=\""+immediateTransitionVertical+"\" x=\""+currentOffsetHorizontal+"\""
					currentOffsetHorizontal = currentOffsetHorizontal + componentOffsetHorizontal
					iTransition.weight=weightDefault
					iTransition.ID = "0." + id.toString
					id ++
					immediateTransitionList.add(iTransition)
				}
			}
			
			//handle places and eventually followed immediateTransitions (for outports)
		for(place : subSubGroup.places)
		{
			var PlaceImpl tempPlace = place as PlaceImpl
			//TODO Position for Place
			
			tempPlace.location = "y=\""+placeVertical+"\" x=\""+currentOffsetHorizontal+"\""
			currentOffsetHorizontal = currentOffsetHorizontal + componentOffsetHorizontal
			
			tempPlace.ID = "0." + id.toString
			id ++
			placeList.add(tempPlace)
			if(!immediateTransitionListTemp.empty)
			{	
				var arcToDelete=newArrayList
				var int currentVerticalOffset = immediateTransitionVertical
				for (arc : ArcListTemp)
				{
					var ArcImpl tempArc = arc as ArcImpl
					if(tempArc.from  == place)
					{
						var transitionsToDelete = newArrayList
						
						for (transition : immediateTransitionListTemp)
						{
							
							var tempTransition = transition as ImmediateTransitionImpl
							
							if(tempArc.to == transition)
							{
								//TODO generate Id, Position for immediateTransition, add to xml
								
								tempTransition.location = "y= \" "+currentVerticalOffset+"\" x=\" "+currentOffsetHorizontal +"\""
								currentVerticalOffset = currentVerticalOffset +componentOffsetVertical
								tempTransition.ID = "0." + id.toString
								id ++
								immediateTransitionList.add(tempTransition)
								transitionsToDelete.add(transition)
								
							}
						}
						//arc cannot be connected to another immediateTransition
						tempArc.ID= "0."+id.toString
						id++
						ArcList.add(tempArc)
						arcToDelete.add(tempArc)
						for(transition : transitionsToDelete)
						{
							immediateTransitionListTemp.remove(transition)
						}
					}
				}
				currentOffsetHorizontal = currentOffsetHorizontal + componentOffsetHorizontal
				for(arc : arcToDelete)
				{
					ArcListTemp.remove(arc)
				}
			}
			
		}
		
		for(arc :subSubGroup.arcs)
		{
			var ArcImpl tempArc = arc as ArcImpl
			
			tempArc.ID = "0." + id.toString
			id ++
			ArcList.add(tempArc) 
		}
			
			currentOffsetHorizontal = currentOffsetHorizontal + componentOffsetHorizontal
	}
	
	
	//Implementations for generation of the components
	def String generatePlace(PlaceImpl place)
	{
		if(place.name !== null)
		{
			return 	 '''<place capacity="0" id="«place.ID»" queue="«place.queue»" tokentype="int" type="node" watch="false">
    						<graphics orientation="0" «place.location»/>
   				 			<label id="«place.ID».0" text="«(place.name+"_in_down")»" type="text">
      							<graphics x="-10" y="-40"/>
    						</label>
  						</place>'''
		}
		else 
		{
			return 	 '''<place capacity="0" id="«place.ID»" queue="«place.queue»" tokentype="int" type="node" watch="false">
    						<graphics orientation="0" «place.location»/>
   				 			<label id="«place.ID».0" text="" type="text">
      							<graphics x="-10" y="-40"/>
    						</label>
  						</place>'''
		}
	}
	
	
	def String generateTimedTransition(TimedTransitionImpl timedTransition)
	{
		return   '''<timedTransition id="«timedTransition.ID»" serverType="ExclusiveServer" specType="Automatic" takeFirst="false" timeFunction="«timedTransition.timeFunction»"
		    			type="node" watch="false">
		    			<graphics orientation="0" «timedTransition.location»/>
		    			<label id="«timedTransition.ID».0" text="«timedTransition.name»" type="text">
		      				<graphics x="-10" y="-40"/>
		    			</label>
		  			</timedTransition>'''
	}
	
	def String generateImmediateTransition(ImmediateTransitionImpl immediateTransition)
	{
		if(immediateTransition.weight==weightDefault){
			return   '''<immediateTransition id="«immediateTransition.ID»" priority="1" serverType="ExclusiveServer" specType="Automatic" takeFirst="false"
		    				type="node" watch="false" weight="«immediateTransition.weight»">
		    				<graphics orientation="0" «immediateTransition.location»/>
		    				<label id="«immediateTransition.ID».0" text="" type="text">
		      					<graphics x="-10" y="-40"/>
		    				</label>
		  				</immediateTransition>'''
		}
		else
		{
			return   '''<immediateTransition id="«immediateTransition.ID»" priority="1" serverType="ExclusiveServer" specType="Automatic" takeFirst="false"
		    				type="node" watch="false" weight="«immediateTransition.weight»">
		    				<graphics orientation="0" «immediateTransition.location»/>
		    				<label id="«immediateTransition.ID».0" text="«immediateTransition.weight»" type="text">
		      					<graphics x="-10" y="-40"/>
		    				</label>
		  				</immediateTransition>'''
		}
	}
	
	def String generateArc(ArcImpl arc)
	{
		var String ret = "Something went WRONG!!!"
		var String tempText = arc.text
		if (tempText === null) {
			tempText = "-"
		}
	 	try {
	 		ret = '''<arc fromNode="«(arc.from as PlaceImpl).ID»" id="«arc.ID»" toNode="«(arc.to as ImmediateTransitionImpl).ID»" type="connector">
	 	    			<inscription id="«arc.ID».0" text="«tempText»" type="inscriptionText">
	 	      				<graphics x="0" y="0"/>
	 	    			</inscription>
	 	  			</arc>'''
	 	}
	 	catch (Exception e) {
	 		try {
	 			ret = '''<arc fromNode="«(arc.from as PlaceImpl).ID»" id="«arc.ID»" toNode="«(arc.to as TimedTransitionImpl).ID»" type="connector">
	 	    			<inscription id="«arc.ID».0" text="«tempText»" type="inscriptionText">
	 	      				<graphics x="0" y="0"/>
	 	    			</inscription>
	 	  			</arc>'''
	 		}
	 		catch (Exception f) {
	 			try {
	 				ret = '''<arc fromNode="«(arc.from as ImmediateTransitionImpl).ID»" id="«arc.ID»" toNode="«(arc.to as PlaceImpl).ID»" type="connector">
	 	    			<inscription id="«arc.ID».0" text="«tempText»" type="inscriptionText">
	 	      				<graphics x="0" y="0"/>
	 	    			</inscription>
	 	  			</arc>'''
	 	  		}
	 	  		catch (Exception g) {
	 	  			ret = '''<arc fromNode="«(arc.from as TimedTransitionImpl).ID»" id="«arc.ID»" toNode="«(arc.to as PlaceImpl).ID»" type="connector">
	 	    			<inscription id="«arc.ID».0" text="«tempText»" type="inscriptionText">
	 	      				<graphics x="0" y="0"/>
	 	    			</inscription>
	 	  			</arc>'''
	 	  			
	 	  		}
	 	  	}
	 	}
	 	
	 	return ret
	}
		
}
